---
title: "Spatial tools"
author: "Arezoo Rafieeinasab & Aubrey Dugger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
For most of the postprocessing, there is a need to create spatial maps, aggregate over spatial units and also produce georeference raster and shapefiles. Many of the existing functions in available spatial libraries such as SP, RGDAL, RGEOS and Raster has been wrapped in rwrfhydro to serve our purpose. Here we explain these spatial functions, their applications as well as some examples.

## List of the available functions
- GetProj
- GetGeogridSpatialInfo
- ExportGeogrid
- GetGeogridIndex
- GetTimeZone
- GetRfc
- GetPoly
- PolygonToRaster

## General Info
The path to the files have been hard coded here, please change them as you see fit. This vignette will wrok with the wrf-hydro-training material provided at June 2018.

Load the rwrfhydro package.

```{r}
library(rwrfhydro)
```

Geogrid file is the main file containing all the base geographic information on the model domain such as the geographic coordinate system, latitude, longitude of each pixel and so on. We use this file frequently. Set a path to geogrid file.

```{r}
geoFile <- '~/wrf-hydro-training/example_case/Gridded/DOMAIN/geo_em.d01.nc'
```


## GetProj

To be able to use any of the spatial tools in R, projection information of the model domain is required. Some of the model input and output files are based on geogrid file domain. `GetProj` pull projection information of WRF-Hydro modeling domain from geogrid file. It takes only the path to the geogrid file and return the projection information as a character.

```{r}
proj4 <- GetProj(geoFile)
proj4
```

## GetGeogridSpatialInfo

It pulls necessary geospatial information about WRF-Hydro modeling domain from geogrid file used for regridding and deprojection.
It only requires the address to the geogrid file and return a data frame containing geospatial information such as the projection information, number of rows and columns and size of the grids.

```{r}
geoInfo <- GetGeogridSpatialInfo(geoFile)
geoInfo
```


## ExportGeogrid

If you need to create a georeferenced TIFF file from any variable in a netcdf file having the same domain and pixel size as the geogrid file, then you need to use `ExportGeogrid` function. It takes the Geogrid file having lat/lon information and converts the specified variable into a georeferenced TIFF file for use in standard GIS tools.
Let's export one variable from the geogrid file. You can get a list of all available variables in the `geoFile` using `ncdump` function in rwrfhydro.

```{r, eval = FALSE}
ncdump(geoFile)
```


We create a georeferenced TIFF file from HGT_M field. You only need to provide the address to geogrid file (`geoFile`), the name of the variable (`HGT_M`) and the name of the output file (`geogrid_hgt.tif`).

```{r, results='hide', message=FALSE, warning=FALSE}
ExportGeogrid(geoFile,"HGT_M", "geogrid_hgt.tif")
```

You can use the provided file in any standard GIS platform. Let's read it into memory as a raster and dispaly it.

```{r plot1, fig.show = "hold", fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
# read the saved tiff file
r <- raster::raster("geogrid_hgt.tif")

# plot the imported raster from tif file
raster::plot(r, main = "HGT_M")

# check the raster information. Notice that geographic coordinate information has been added.
r
```


Many of the input and output files such as LDASOUT output file does not contain lat/lon coordinates but matches the spatial coordinate system of the geogrid input file. In that case, you could feed the geogrid file (`geoFile`) from which the lat/lon information will be taken.

```{r plot2, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
file = "~/wrf-hydro-training/example_case/FORCING/2011082800.LDASIN_DOMAIN1"
# ncdump(file) # check if the SOIL_T exist in the file

# we will read the third layer of soil temperature
ExportGeogrid(file,
              inVar="RAINRATE",
              outFile="RAINRATE.tif",
              inCoordFile=geoFile)

# read the  created tiff file
r <- raster::raster("RAINRATE.tif")

# plot the imported raster from tiff file
raster::plot(r*3600, main = "RAINRATE (mm/hr)")

# check the raster information and notice geographic coordinate information has been added
r
```


## GetGeogridIndex

To be able to use a bunch of tools such as `GetMultiNcdf`, one needs to have the indices (x,y) or the location of each cell within the domain. `GetGeogridIndex` get geogrid cell indices from lat/lon (or other) coordinates. `GetGeogridIndex` reads in a set of lat/lon (or other) coordinates and generates a corresponding set of geogrid index pairs. You can assign a projection to the points using `proj4` argument which will be used to transform the point to the `geoFile` coordinate system. Chkeck the vignette on precipitation for usage. If the point falls outside the domain, it will return `NA` value. 

```{r}
sg <- data.frame(lon = seq(-73.6, -73.8, length.out = 10),
                 lat = seq(41.4, 41.5, length.out = 10))
GetGeogridIndex(sg, geoFile)

```


## GetTimeZone

Many of the point observation are reported in local time and needs to be converted to UTC time to be comparable with WRF-Hydro input and outputs. `GetTimeZone` return the time zone for any point having longitude and latitude. It takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the `points` with a timezone shapefile (can be downloded from <http://efele.net/maps/tz/world/>). The shapefile is provided in rwrfhydro data and it is called `timeZone`.

```{r}
# timeZone has been provided by rwrfhydro as a SpatialPolygonDataFrame
class(timeZone)

# Shows the available timezone (TZID column in timeZone@data)
head(timeZone@data)
```

Function has three arguments.

- `points`: A dataframe of the points. The dataframe should contain at least two fields called `latitude` and `longitude`.
- `proj4`: Projection of the `points` to be used in transforming the `points` projection to `timeZone` projection. Default is `+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0` which is the same as the `timezone` projection.
- `parallel`: If the number of points are high you can parallelize the process.

It will return the `points` dataframe with an added column called `timeZone`. It will return NA in case the point is not in any polygon. Now let's generate some random points and find their time zone information.

```{r}
# Provide a dataframe of 10 points having longitude and latitude as column name.
sg <- data.frame(longitude = seq(-110, -80, length.out = 10),
latitude = seq(30, 50, length.out = 10))

# Find the time zone for each point
sg <- GetTimeZone(sg)
sg
```

## GetRfc

US has 13 River Forecast Centers (RFC) and many of the statistics are desired to be grouped into River Forecast Center level so it would be easier to compare with the performance of the RFC models in the past. The RFC boundary shapefile is provided in rwrfhydro data and is called `rfc`.

```{r}
class(rfc)

# Shows the available rfc, name of the column is BASIN_ID
head(rfc@data)
```

`GetRfc` return the RFC name for any point having `longitude` and `latitude`. It takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the points with a `rfc` SpatialPolygonDataFrame and return the rfc's BASIN_ID. Function has three arguments.

- `points`: A dataframe of the points. The dataframe should contain at least two fields called "latitude" and "longitude".
- `proj4`: Projection of the `points` to be used in transforming the `points` projection to `rfc` projection. Default is `+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0`.
- `parallel`: If the number of points are high you can parallelize the process.

It will return the `points` dataframe with an added column called `rfc`. It will return NA in case the point is not within RFCs.

```{r}
# Provide a dataframe of 10 points having longitude and latitude as column name.
sg <- data.frame(longitude = seq(-110, -80, length.out = 10),
                 latitude = seq(30, 50, length.out = 10))

# Find the rfc for each point
sg <- GetRfc(sg)
sg
```

## GetPoly

`Getpoly` is similar to `GetRfc`, it is a wrapper for function `sp::over`. It takes a dataframe containing at least two fields of `latitude` and `longitude`, overlays the points with a `SpatialPolygonDataFrame` and return the requested attribute from the polygon. One could use the available `SpatialPolygon*` loaded into memory or provide the address to the location of a polygon shapefile and the name of the shapefile and it will read the polygon using `rgdal::readOGR` function.

Let's get the RFC information from `GetPoly` instead of `GetRfc`. Here we provide the name of the `SpatialPolygon*` and using argument `join` request one of the attributes of the polygon. For example, here we have requested the `BASIN_ID`, `RFC_NAME` and `RFC_CITY`.

```{r}
# Provide a dataframe of 10 points having longitude and latitude
sg <- data.frame(longitude = seq(-110, -80, length.out = 10),
latitude = seq(30, 50, length.out = 10))

# Find the ID of RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "BASIN_ID")

# Find the full name of RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "RFC_NAME")

# Find the location/city of RFC for each point
sg <- GetPoly(points = sg, polygon = rfc, join = "RFC_CITY")
sg
```

## PolyToRaster

If one wants to create a mask in the model domain (geogrid file), then needs to use `PolyToRaster`. It first picks up the required geographic information (like `proj4`) from the geogrid file (`geoFile`) and then use `raster::rasterize` function to grab the mask or attribute values from the `SpatialPolygonDataFrame`. This function is basically wrapping the `raster::rasterize` function to serve our purpose. Below is a few different ways one could use this function.

Example 1 :
  Let's get the RFC's ID for each pixel within the Fourmile Creek domain. This is equivalent to rasterizing the `rfc` `SpatialPolygonDataFrame` based on the `BASIN_ID`.

```{r plot3, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  useRfc = TRUE,
                  field ="BASIN_ID")
```

To know what are the corresponding values to the integer values used in rasterized output, use the following command.

```{r}
r@data@attributes
```
As the result shows the rectangle domain is in CBRFC and MBRFC.


Example 2 :
Rasterize the HUC12 `SpatialPolygonDataFrame` based on the `HUC12` field. The Clipped HUC12 shapefile is provided with the test case which is slightly bigger than the model domain. You could read the shapefile and plot it as below.
  
```{r results="hide", plot4, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
polyg <- rgdal::readOGR("~/wrf-hydro-training/example_case/supplemental/polygons", "Clipped_huc12")
raster::plot(polyg, main = "Clipped HUC12")
```

Our study domain covers some of the HUCs.

```{r results="hide", plot5, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
polygonAddress <- "~/wrf-hydro-training/example_case/supplemental/polygons"
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "Clipped_huc12",
                  field ="HUC12",
                  plot = FALSE)
```

To get the `HUC12` actual values:
  
```{r}
r@data@attributes
```

Example 3: You can get a unified mask over the study domain as follows:
  
```{r results="hide", plot6, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "Clipped_huc12",
                  mask =TRUE)
```

Example 4: You could also get a separate mask for each subbasin (HUC12 in this case) with the fraction of each grid cell that is covered by each polygon. The fraction covered is estimated by dividing each cell into 100 subcells and determining presence/absence of the polygon in the center of each subcell.

```{r results="hide", plot7, fig.width = 8, fig.height = 8, out.width='600', out.height='600'}
r <- PolyToRaster(geoFile = geoFile,
                  polygonAddress = polygonAddress,
                  polygonShapeFile = "Clipped_huc12",
                  field = "HUC12",
                  getCover = TRUE)
raster::plot(r)
```


